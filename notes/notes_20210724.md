## Getting Oriented

Upon opening ElevatorSaga.com for the first time, these are my initial reflections:

Elevator Saga appears to be an optimization game built upon the premise that we're transporting people on an elevator from level to level, maximizing for the amount of people transported within a period of time.

Presumably the coder/developer must solve different optimization problems as time proceeds.

### Initial Debug Problem

The below code is given at the start, minus the command, "elevator.goToFloor(2);" - which means that the initial code does not execute properly, leaving, "passengers," stranded on the top floor (index 2).

```
{
    init: function(elevators, floors) {
        var elevator = elevators[0]; // Let's use the first elevator

        // Whenever the elevator is idle (has no more queued destinations) ...
        elevator.on("idle", function() {
            // let's go to all the floors (or did we forget one?)
            elevator.goToFloor(0);
            elevator.goToFloor(1);
            elevator.goToFloor(2);
        });
    },
    update: function(dt, elevators, floors) {
        // We normally don't need to do anything here
    }
}
```
Upon successfully adding the (2) index in the IDE, the challenge is pre-solved to be able to transport 15 passengers (P=15) within 60 seconds (ET=60) among 3 floors (F=3).

### Sub-Metrics

There are several sub-metrics given on the side screen:

* Elapsed time (ET)
* Transported/s (TPS)
* Avg waiting time (TWAVG)
* Max waiting time (TWMAX)

Other observable measurements:

* Elevator maximum capacity (EMC) = 4

### Apparent Passenger Release Pattern

Running the elevator sequence twice we get the following release patterns:

* first_trial: [0,1,2,2,0,0,1,0,0,1,0,2,0,2,0,0]
* first_trial: [1,0,0,2,0,1,1,1,2,1,1,1,0,1,0,0]

Note that the pattern was different for each release, there evidently appears to be some kind of randomness introduced to the release pattern, whether that randomness is completely uniform or not is not known at this time as we don't have a sufficient sample.

### Fourth Floor Introduced

Upon solving the first debug challenge, a fourth floor is introduced, leading to a discrete sampling problem.

Initially the code presented is the same as the first challenge. Adding additional floors in sequence leads to a, "passenger overflow error" in which the elevator continuously attempts to return and prioritizes lower floors in order to pick up missing passengers, meaning the elevator never climbs above floor 3, and the loaded passengers never exit.

```
{
    init: function(elevators, floors) {
        var elevator = elevators[0]; // Let's use the first elevator

        // Whenever the elevator is idle (has no more queued destinations) ...
        elevator.on("idle", function() {
            // let's go to all the floors (or did we forget one?)
            elevator.goToFloor(0);
            elevator.goToFloor(1);
            elevator.goToFloor(2);
            elevator.goToFloor(3);
            elevator.goToFloor(4);
            elevator.goToFloor(5);
        });
    },
    update: function(dt, elevators, floors) {
        // We normally don't need to do anything here
    }
```

The passenger release function appears to be similarly uniformly distributed, as such this is an expected outcome since the elevator maximum capacity is 4.

### Initial Read of Documentation

While there may be an obvious optimization at this stage, presumably this is a good time to start reading [the documentation](https://play.elevatorsaga.com/documentation.html).

Beyond the documentation, there is also a Github repo, with the source code for the game itself available. [Challenges](https://github.com/magwo/elevatorsaga/blob/master/challenges.js) appear to layout the structure of future problems in terms of the following variables:

```
floorCount: (presumably the number of floors)
elevatorCount: (presumably the number of elevators)
spawnRate: (presumably the passenger respwan rate)
elevatorCapacities: (presumably the capacity of each elevator)
condition: requireUserCountWithinTime(70, 80) (presumably the time limit)
```
With the above variables, it might hypothetically be possible to jump forward in levels and, "mathematically solve," the program as one all-encompassing release which, "solves the program downward." However for learning purposes since there may be unforeseen anomalies it's probably best to start off solving challenge by challenge.

### Generalization Goal

The following specification was given for the project:

* Each solution to a given challenge # in elevatorsaga should be tagged as a release in your repo.  The hope is your solution can solve each challenge as one large program, not lots of smaller programs.

Nothing within this statement says that we can't shoot for the most generalizeable solution possible early in the game and then continue to build on each challenge based upon the most case agnostic solution from there on out.

### Playing with the IDE

To ensure capability to extract variables from the IDE, the following code was created to attempt to print out, "pressed button," commands to console.

```
{
    init: function(elevators, floors) {
        var elevator = elevators[0]; // Let's use the first elevator

        // Whenever the elevator is idle (has no more queued destinations) ...
        elevator.on("idle", function() {            
            // print out pressed floors
            elevator.logpressedfloors();
        });

        elevator.logpressedfloors = function() {
            // get the pressed floors
            if(elevator.getPressedFloors().length > 0) {
                // getPressedFloors returns an arr per github source
                var pressedFloors = elevator.getPressedFloors()
                // print to console
                console.log('pressedFloors:',pressedFloors)
            }
        }

    },

    update: function(dt, elevators, floors) {
        // We normally don't need to do anything here
    }
}
```

![](/img/consolelog_pressedbuttonarray.png)

![](/img/gamescreenshot_bushedbuttonsarray.png)

### General Solution Optimization Research

Through a quick review of literature around elevator scheduling, it seems that there are at least two distinct schools of thought on the problem from a mathematical perspective:

* Literal Elevator Scheduling (LES), improving how actual elevators operate in the physical world.
* Hard Disk Arm Read Scheduling (HDARS), which involves a set of programming algorithms which in this world they call, "the elevator scheduling problem," which is similar to Literal Elevator Scheduling, but more idealized.

Quick notes on the above:

* Some blogs on LES refer to HDARS and vice versa.
* LES seems to involve using HDARS in some cases but also may involve algorithms which might not typically be discussed in HDARS such as using Markov models to optimize decision making.
* For the most part, Elevator Saga seems to model HDARS because the, "passengers," seem likely to spawn at any given floor at any time and get off at any floor at any time rather than in a physical world elevator in which passengers are more likely to have a highly utilized port on the ground level since people tend to leave buildings. In other words, there is a much higher probability field in a real world elevator than within Elevator Saga - which more approximates the world of reading data from rotating disks.
* Also note that somewhat confusingly, one type of HDARS is also known as, "Elevator Scheduling," but it is also known as SCAN.

#### Found Resources on Rotating Disk Algorithms

* [Disks and I/O Scheduling](https://www.cs.unc.edu/~porter/courses/comp530/f20/slides/disk-scheduling.pdf)
* [Wikipedia - Elevator Algorithm](https://en.wikipedia.org/wiki/Elevator_algorithm)
* [Wikipedia - FIFO](https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)
* [Wikipedia - FSCAN](https://en.wikipedia.org/wiki/FSCAN)
* [Wikipedia - NStep-SCAN](https://en.wikipedia.org/wiki/N-Step-SCAN)
* [Wikipedia - LOOK](https://en.wikipedia.org/wiki/LOOK_algorithm)

##### Summary of Disks and I/O Scheduling Presentation PDF

* Presentation suggests building a formula to optimize for latency.
* First off, there is the FCFS algorithm - Assume a queue of requests exists to read/write tracks, follow that queue. This does not optimize for time.
* SSTF or, "Greedy" scheduling suggests rearranging the queue by, "shortest time." So using a latency formula, minimuze total latency by rearranging the queue.
* There are problems with SSTF/Greedy, in that, "farther away," requests starve for waiting time, and the disk head (or in our case, elevator) tends to hover toward the middle.
* SCAN scheduling suggests just moving the head/elevator in one direction until all requests have
been serviced, and then reverse. This particular algorithm is also known as, "Elevator Scheduling."
* SCAN seems most efficient in general.
* Circular SCAN (CSCAN): Move the head in one direction until an edge of the disk is reached, and then reset to the opposite edge.
* C-SCAN offers better fairness at marginal cost, may be better under certain workloads.

This presentation goes into:

* Disk partitioning, and
* Redundant Arrays of Inexpensive Disks (RAID) - which helps with throughput.

RAID may be analogous to multiple elevators. We may return to optimization under these conditions later in the Elevator Saga.

### Psuedocode Draft Based Upon Basic Understanding of Standard Algorithms

#### SCAN

> ...moving the head/elevator in one direction until all requests have
been serviced, then reverse...

```

{
  init: function(elevators, floors) {

    // by convention, start at floor 0 - BOTTOMFLOOR = 0

    // pop top floor into, "schedule" destinationQueue and start elevator immediately, don't wait for lower floor passenger

    // Find maximum number of floors, topFloor - NUMFLOORS / TOPFLOOR (for general solution)

    // Estimate passenger quantity, or at least if there are any passengers with loadFactor > 0

    // if there are passengers, proceed, if not idle() until allRequests has floor along path

    // Check exterior requests prior to each passing_floor with floor_button_pressed - exteriorRequests

    // Check continuously, interior requests: getPressedFloors - interiorRequests

    // combine interiorRequests and exteriorRequests into allRequests, order allRequests sequentially relative to current position and SCAN direction

    // update "schedule" destinationQueue based upon allRequests and currentFloor

    // Move elevator toward topFloor -> goToFloor in topFloor direction

    // At each floorNum reached, if currentFloor === one_of_the( allRequests ), reload passengers

    // NOTE --- do not use, "stop" - this is used for a different purpose, not for stopping at floors

    // Once reached TopFloor, insert bottom floor [0] into scheduling queue - destinationQueue.

    // repeat the above pattern in reverse until reaching BOTTOMFLOOR

    // Repeat pattern back to TOPFLOOR


  }

}

```

Note -

* "exterior requests" (wall buttons) appear to be the array from floor_button_pressed
* "interior requests" (elevator floor buttons) appear to be getPressedFloors
* use going up / going down indicators to affect possible passenger behavior, "somehow" (per the documentation)

The below variables were not used in the above pseudocode thus far:

* maxPassengerCount - the actual capacity of the elevator
* goingUpIndicator / goingDownIndicator
* destinationDirection
* stopped_at_floor
* idle

##### Possible Ideas to Improve Above Hypothetical Solution

* Don't stop at exterior pushed floor unless equal to interior pushed floor if elevator is, "full," (which is an estimate based upon loadFactor)
* Possibly wait for lower floor passenger if we find that there is ideed a bias toward that floor

#### Further Documentation Notes

We noticed in the documentation:

> goingDownIndicator / goingUpIndicator - Gets or sets the going down/up indicator, which will affect passenger behavior when stopping at floors.

This may indicate that request changes may adjust based upon elevator availability - e.g. the passengers may have some intelligence built-in which could help optimize for elevator throughput.
