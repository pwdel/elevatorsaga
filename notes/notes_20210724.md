## Getting Oriented

Upon opening ElevatorSaga.com for the first time, these are my initial reflections:

Elevator Saga appears to be an optimization game built upon the premise that we're transporting people on an elevator from level to level, maximizing for the amount of people transported within a period of time.

Presumably the coder/developer must solve different optimization problems as time proceeds.

### Initial Debug Problem

The below code is given at the start, minus the command, "elevator.goToFloor(2);" - which means that the initial code does not execute properly, leaving, "passengers," stranded on the top floor (index 2).

```
{
    init: function(elevators, floors) {
        var elevator = elevators[0]; // Let's use the first elevator

        // Whenever the elevator is idle (has no more queued destinations) ...
        elevator.on("idle", function() {
            // let's go to all the floors (or did we forget one?)
            elevator.goToFloor(0);
            elevator.goToFloor(1);
            elevator.goToFloor(2);
        });
    },
    update: function(dt, elevators, floors) {
        // We normally don't need to do anything here
    }
}
```
Upon successfully adding the (2) index in the IDE, the challenge is pre-solved to be able to transport 15 passengers (P=15) within 60 seconds (ET=60) among 3 floors (F=3).

### Sub-Metrics

There are several sub-metrics given on the side screen:

* Elapsed time (ET)
* Transported/s (TPS)
* Avg waiting time (TWAVG)
* Max waiting time (TWMAX)

Other observable measurements:

* Elevator maximum capacity (EMC) = 4

### Apparent Passenger Release Pattern

Running the elevator sequence twice we get the following release patterns:

* first_trial: [0,1,2,2,0,0,1,0,0,1,0,2,0,2,0,0]
* first_trial: [1,0,0,2,0,1,1,1,2,1,1,1,0,1,0,0]

Note that the pattern was different for each release, there evidently appears to be some kind of randomness introduced to the release pattern, whether that randomness is completely uniform or not is not known at this time as we don't have a sufficient sample.

### Fourth Floor Introduced

Upon solving the first debug challenge, a fourth floor is introduced, leading to a discrete sampling problem.

Initially the code presented is the same as the first challenge. Adding additional floors in sequence leads to a, "passenger overflow error" in which the elevator continuously attempts to return and prioritizes lower floors in order to pick up missing passengers, meaning the elevator never climbs above floor 3, and the loaded passengers never exit.

```
{
    init: function(elevators, floors) {
        var elevator = elevators[0]; // Let's use the first elevator

        // Whenever the elevator is idle (has no more queued destinations) ...
        elevator.on("idle", function() {
            // let's go to all the floors (or did we forget one?)
            elevator.goToFloor(0);
            elevator.goToFloor(1);
            elevator.goToFloor(2);
            elevator.goToFloor(3);
            elevator.goToFloor(4);
            elevator.goToFloor(5);
        });
    },
    update: function(dt, elevators, floors) {
        // We normally don't need to do anything here
    }
```

The passenger release function appears to be similarly uniformly distributed, as such this is an expected outcome since the elevator maximum capacity is 4.

### Initial Read of Documentation

While there may be an obvious optimization at this stage, presumably this is a good time to start reading [the documentation](https://play.elevatorsaga.com/documentation.html).

Beyond the documentation, there is also a Github repo, with the source code for the game itself available. [Challenges](https://github.com/magwo/elevatorsaga/blob/master/challenges.js) appear to layout the structure of future problems in terms of the following variables:

```
floorCount: (presumably the number of floors)
elevatorCount: (presumably the number of elevators)
spawnRate: (presumably the passenger respwan rate)
elevatorCapacities: (presumably the capacity of each elevator)
condition: requireUserCountWithinTime(70, 80) (presumably the time limit)
```
With the above variables, it might hypothetically be possible to jump forward in levels and, "mathematically solve," the program as one all-encompassing release which, "solves the program downward." However for learning purposes since there may be unforeseen anomalies it's probably best to start off solving challenge by challenge.

### Generalization Goal

The following specification was given for the project:

* Each solution to a given challenge # in elevatorsaga should be tagged as a release in your repo.  The hope is your solution can solve each challenge as one large program, not lots of smaller programs.

Nothing within this statement says that we can't shoot for the most generalizeable solution possible early in the game and then continue to build on each challenge based upon the most case agnostic solution from there on out.

### Playing with the IDE

To ensure capability to extract variables from the IDE, the following code was created to attempt to print out, "pressed button," commands to console.

```
{
    init: function(elevators, floors) {
        var elevator = elevators[0]; // Let's use the first elevator

        // Whenever the elevator is idle (has no more queued destinations) ...
        elevator.on("idle", function() {            
            // print out pressed floors
            elevator.logpressedfloors();
        });

        elevator.logpressedfloors = function() {
            // get the pressed floors
            if(elevator.getPressedFloors().length > 0) {
                // getPressedFloors returns an arr per github source
                var pressedFloors = elevator.getPressedFloors()
                console.log('pressedfloors:',pressedFloors)
            }
        }

    },

    update: function(dt, elevators, floors) {
        // We normally don't need to do anything here
    }
}
```

![](/img/consolelog_pressedbuttonarray.png)

![](/img/gamescreenshot_bushedbuttonsarray.png)
